{"componentChunkName":"component---src-templates-project-js","path":"/projects/Static_Single_Assignment(SSA)_in_compilers/ssa/","result":{"data":{"markdownRemark":{"html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/21a5f1a41075105ae4b26d86969ae6b3/39c09/ssa.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 88.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACDklEQVQ4y22U5w7CMAyE+/5PBWIIBIgfCFH2XmXvjdFnyVEKRAqpE9s5ny8EIiLX61W2260cDgc3d7ud3G43juX9fut6Pp//+t3vd+cX8LFYLCSfz0s2m5VcLieJREIKhYKs12t1fL1euo7HY0mn0+rDTCaTUiqVNHEsIYHtdtvN6XSqwfv9PpYwiiJptVpSr9elVqvJbDaT4XCoyGMJCWCTm0jGAWU8n0/n+Hg81A8aKHO1WrnL8OOcoQlBQgJKr1QqahN4uVzUiQAuCsNQEfZ6PV0bjYYi7Xa7GuMQEghCNinD5mQycYRzBjWslA41m81Gm8S0sjWhjePxKM1mU1GWy2UpFouKwkq3ARIQmwr8EZgcmMvlUgkHHeWD4HQ6OX745lIQ0jS4xPblFfBDMygbRxCyUioJfB3ix95oNFI+KZWExnWsy6AwfrARu8nFElo3SdDv9x163y8ALmgwKAGyLZh9O2MQjE0MsgEddiwhnUOctH4wGGhCJEHp2KC2pvBNEvY5h2PsmLBNDjbpHs0BATYBhoBSoYKGcTGJ2Pt5y5QCH5AON5SE7b8USwgAmgHXpl1TgUvIIXrLZDI6efi8AJD6bxmhV6tVSaVSzo9uw/3Pn4M9JZ4VgUjDHL//HDqdjvKOjZ8vLycbyiQxTr6uvleC4RkefWTmE9gHAwfQ/XP0tQgV8/lcG2c+Nj+GFmC/9qAL2wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ssa\"\n        title=\"ssa\"\n        src=\"/static/21a5f1a41075105ae4b26d86969ae6b3/39c09/ssa.png\"\n        srcset=\"/static/21a5f1a41075105ae4b26d86969ae6b3/8ff5a/ssa.png 240w,\n/static/21a5f1a41075105ae4b26d86969ae6b3/e85cb/ssa.png 480w,\n/static/21a5f1a41075105ae4b26d86969ae6b3/39c09/ssa.png 624w\"\n        sizes=\"(max-width: 624px) 100vw, 624px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>In computer programming, as in real life, names are useful handles for concrete entities. The key point about SSA is that having unique names for distinct entities reduces uncertainty and imprecision.</p>\n<p>For example,\nConsider overhearing a conversation about ‘Apple.’ Without any more contextual clues, you cannot disambiguate between the fruit Apple and Apple the American multinational technology company.\nAs soon as the conversation mentions iPhone (rather than the fruit properties), you are fairly sure that the company Apple(rather than the fruit) is the subject. On the other hand, if everyone had a unique name, then there would be no possibility of confusing one of the largest brand on the planet with a fruit that grows in hilly areas.</p>\n<p>The <strong>Static Single Assignment form(SSA)</strong>, is a naming convention for storage locations(variables) in low-level representations of computer programs. The term static indicates that SSA relates to properties and analysis of program text (code). The terms in general refer to the uniqueness property of variable names that SSA imposes. As from the example above, this enables a greater degree of precision. The term assignment means variable definitions.\nLike, in the code</p>\n<pre><code>x=y+1;\n</code></pre>\n<p>the variable <code>x</code> is being assigned the value of expression <code>(y+1)</code>. This is a definition,or assignment statement, for <code>x</code>. A compiler engineer would interpret the above assignment statement to mean that the value of <code>x</code>(i.e., the memory location labeled as x) should be modified to store the value <code>(y+1)</code>.</p>\n<h2>So what's SSA?</h2>\n<p><strong>A program is defined to be in SSA form if each variable is a target of exactly one assignment statement in the program text.</strong></p>\n<p>However there are various, more specialized, varieties of SSA, which impose further constraints on programs. Such constraints may relate to graph-theoretic properties  of  variable  definitions  and  uses,  or  the  encapsulation  of  specific control-flow or data-flow information. Each distinct SSA variety has specific characteristics.\nOne important property that holds for all varieties of SSA, including the simplest definition above, is referential transparency. i.e., since there is only a single definition for each variable in the program text, a variable’s value is independent of its position in the program. We may refine our knowledge about a particular variable based on branching conditions, e.g. we know the value of <code>x</code> in the conditionally executed block following an if-statement that begins with\n<code>if(x==0)</code>\nhowever the underlying value of <code>x</code> does not change at this <code>if</code> statement. Programs written in pure functional languages are referentially transparent. Such referentially transparent programs are more amenable to formal methods and mathematical reasoning, since the meaning of an expression depends only on the meaning of its sub-expressions and not on the order of evaluation or side effects of other expressions.</p>\n<h2>History of SSA</h2>\n<p>Throughout the 1980s, as optimizing compiler technology became more mature, various <strong>intermediate representations</strong> (IRs) were proposed to encapsulate data dependence in a way that enabled fast and accurate data-flow analysis. The motivation behind the design of such IRs was the exposure of direct links between variable definitions and uses, known as def-use chains,enabling efficient propagation of data-flow information. Static single assignment form was one such IR, which was developed at IBM Research, and announced publicly in several research papers in the late 1980s.\nSSA rapidly acquired popularity due to its intuitive nature and straight-forward construction algorithm. The SSA property gives a standardized shape for variable def-use chains, which simplifies data-flow analysis techniques.Current Usage.The majority of current commercial and open-source compilers,including <strong>GCC</strong>, <strong>LLVM</strong>, the <strong>HotSpot Java virtual machine</strong>, and the <strong>V8 JavaScript engine</strong>, use SSA as a key intermediate representation for program analysis. As optimizations in SSA are fast and powerful, SSA is increasingly used in <strong>just-in-time (JIT)</strong> compilers that operate on a high-level target-independent program representation such as <strong>Java byte-code</strong>, <strong>CLI byte-code</strong> (.NET MSIL), or <strong>LLVM bitcode</strong>. Also High-level functional languages like <strong>Julia/Python</strong> etc. claim referential transparency as one of the cornerstones of their programming paradigm. Thus functional programming supports the SSA property implicitly.</p>\n<h2>Benefits of SSA</h2>\n<h3>There are three major advantages to SSA:</h3>\n<ul>\n<li><strong>Compile time benefit</strong> : Certain compiler optimizations can be more efficient when operating on SSA programs, since referential transparency means that data-flow information can be associated directly with variables, rather than with variables at each program point.</li>\n<li><strong>Compiler development benefit</strong> : Program analyses and transformations can be easier to express in SSA. This means that compiler engineers can be more productive, in writing new compiler passes, and debugging existing passes.For example, the dead code elimination pass in GCC 4.x, which relies on an underlying SSA-based intermediate representation, takes only 40% as many lines of code as the equivalent pass in GCC 3.x, which does not use SSA.The SSA version of the pass is simpler, since it relies on the general-purpose,factored-out, data-flow propagation engine.</li>\n<li><strong>Program runtime benefit</strong> : Conceptually, any analysis and optimization that can be done under SSA form can also be done identically out of SSA form.Because of the compiler development mentioned above, several compiler optimizations are shown to be more effective when operating on programs in SSA form.</li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 624px; "},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"a","properties":{"className":["gatsby-resp-image-link"],"href":"/static/21a5f1a41075105ae4b26d86969ae6b3/39c09/ssa.png","style":"display: block","target":"_blank","rel":["noopener"]},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 88.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACDklEQVQ4y22U5w7CMAyE+/5PBWIIBIgfCFH2XmXvjdFnyVEKRAqpE9s5ny8EIiLX61W2260cDgc3d7ud3G43juX9fut6Pp//+t3vd+cX8LFYLCSfz0s2m5VcLieJREIKhYKs12t1fL1euo7HY0mn0+rDTCaTUiqVNHEsIYHtdtvN6XSqwfv9PpYwiiJptVpSr9elVqvJbDaT4XCoyGMJCWCTm0jGAWU8n0/n+Hg81A8aKHO1WrnL8OOcoQlBQgJKr1QqahN4uVzUiQAuCsNQEfZ6PV0bjYYi7Xa7GuMQEghCNinD5mQycYRzBjWslA41m81Gm8S0sjWhjePxKM1mU1GWy2UpFouKwkq3ARIQmwr8EZgcmMvlUgkHHeWD4HQ6OX745lIQ0jS4xPblFfBDMygbRxCyUioJfB3ix95oNFI+KZWExnWsy6AwfrARu8nFElo3SdDv9x163y8ALmgwKAGyLZh9O2MQjE0MsgEddiwhnUOctH4wGGhCJEHp2KC2pvBNEvY5h2PsmLBNDjbpHs0BATYBhoBSoYKGcTGJ2Pt5y5QCH5AON5SE7b8USwgAmgHXpl1TgUvIIXrLZDI6efi8AJD6bxmhV6tVSaVSzo9uw/3Pn4M9JZ4VgUjDHL//HDqdjvKOjZ8vLycbyiQxTr6uvleC4RkefWTmE9gHAwfQ/XP0tQgV8/lcG2c+Nj+GFmC/9qAL2wAAAABJRU5ErkJggg=='); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"alt":"ssa","title":"ssa","src":"/static/21a5f1a41075105ae4b26d86969ae6b3/39c09/ssa.png","srcSet":["/static/21a5f1a41075105ae4b26d86969ae6b3/8ff5a/ssa.png 240w","/static/21a5f1a41075105ae4b26d86969ae6b3/e85cb/ssa.png 480w","/static/21a5f1a41075105ae4b26d86969ae6b3/39c09/ssa.png 624w"],"sizes":"(max-width: 624px) 100vw, 624px","style":"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;","loading":"lazy","decoding":"async"},"children":[]},{"type":"text","value":"\n  "}]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In computer programming, as in real life, names are useful handles for concrete entities. The key point about SSA is that having unique names for distinct entities reduces uncertainty and imprecision."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For example,\nConsider overhearing a conversation about ‘Apple.’ Without any more contextual clues, you cannot disambiguate between the fruit Apple and Apple the American multinational technology company.\nAs soon as the conversation mentions iPhone (rather than the fruit properties), you are fairly sure that the company Apple(rather than the fruit) is the subject. On the other hand, if everyone had a unique name, then there would be no possibility of confusing one of the largest brand on the planet with a fruit that grows in hilly areas."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Static Single Assignment form(SSA)"}]},{"type":"text","value":", is a naming convention for storage locations(variables) in low-level representations of computer programs. The term static indicates that SSA relates to properties and analysis of program text (code). The terms in general refer to the uniqueness property of variable names that SSA imposes. As from the example above, this enables a greater degree of precision. The term assignment means variable definitions.\nLike, in the code"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x=y+1;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"the variable "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" is being assigned the value of expression "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"(y+1)"}]},{"type":"text","value":". This is a definition,or assignment statement, for "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":". A compiler engineer would interpret the above assignment statement to mean that the value of "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":"(i.e., the memory location labeled as x) should be modified to store the value "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"(y+1)"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"So what's SSA?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"A program is defined to be in SSA form if each variable is a target of exactly one assignment statement in the program text."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However there are various, more specialized, varieties of SSA, which impose further constraints on programs. Such constraints may relate to graph-theoretic properties  of  variable  definitions  and  uses,  or  the  encapsulation  of  specific control-flow or data-flow information. Each distinct SSA variety has specific characteristics.\nOne important property that holds for all varieties of SSA, including the simplest definition above, is referential transparency. i.e., since there is only a single definition for each variable in the program text, a variable’s value is independent of its position in the program. We may refine our knowledge about a particular variable based on branching conditions, e.g. we know the value of "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" in the conditionally executed block following an if-statement that begins with\n"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"if(x==0)"}]},{"type":"text","value":"\nhowever the underlying value of "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"x"}]},{"type":"text","value":" does not change at this "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"if"}]},{"type":"text","value":" statement. Programs written in pure functional languages are referentially transparent. Such referentially transparent programs are more amenable to formal methods and mathematical reasoning, since the meaning of an expression depends only on the meaning of its sub-expressions and not on the order of evaluation or side effects of other expressions."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"History of SSA"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Throughout the 1980s, as optimizing compiler technology became more mature, various "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"intermediate representations"}]},{"type":"text","value":" (IRs) were proposed to encapsulate data dependence in a way that enabled fast and accurate data-flow analysis. The motivation behind the design of such IRs was the exposure of direct links between variable definitions and uses, known as def-use chains,enabling efficient propagation of data-flow information. Static single assignment form was one such IR, which was developed at IBM Research, and announced publicly in several research papers in the late 1980s.\nSSA rapidly acquired popularity due to its intuitive nature and straight-forward construction algorithm. The SSA property gives a standardized shape for variable def-use chains, which simplifies data-flow analysis techniques.Current Usage.The majority of current commercial and open-source compilers,including "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"GCC"}]},{"type":"text","value":", "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"LLVM"}]},{"type":"text","value":", the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"HotSpot Java virtual machine"}]},{"type":"text","value":", and the "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"V8 JavaScript engine"}]},{"type":"text","value":", use SSA as a key intermediate representation for program analysis. As optimizations in SSA are fast and powerful, SSA is increasingly used in "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"just-in-time (JIT)"}]},{"type":"text","value":" compilers that operate on a high-level target-independent program representation such as "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Java byte-code"}]},{"type":"text","value":", "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"CLI byte-code"}]},{"type":"text","value":" (.NET MSIL), or "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"LLVM bitcode"}]},{"type":"text","value":". Also High-level functional languages like "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Julia/Python"}]},{"type":"text","value":" etc. claim referential transparency as one of the cornerstones of their programming paradigm. Thus functional programming supports the SSA property implicitly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Benefits of SSA"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"There are three major advantages to SSA:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Compile time benefit"}]},{"type":"text","value":" : Certain compiler optimizations can be more efficient when operating on SSA programs, since referential transparency means that data-flow information can be associated directly with variables, rather than with variables at each program point."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Compiler development benefit"}]},{"type":"text","value":" : Program analyses and transformations can be easier to express in SSA. This means that compiler engineers can be more productive, in writing new compiler passes, and debugging existing passes.For example, the dead code elimination pass in GCC 4.x, which relies on an underlying SSA-based intermediate representation, takes only 40% as many lines of code as the equivalent pass in GCC 3.x, which does not use SSA.The SSA version of the pass is simpler, since it relies on the general-purpose,factored-out, data-flow propagation engine."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Program runtime benefit"}]},{"type":"text","value":" : Conceptually, any analysis and optimization that can be done under SSA form can also be done identically out of SSA form.Because of the compiler development mentioned above, several compiler optimizations are shown to be more effective when operating on programs in SSA form."}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"frontmatter":{"title":"Static Single Assignment(SSA) in compilers","author":"Arsh Sharma","email":"sharmarsh15@gmail.com","date":"December 22nd, 2020","tags":["compilers","development"]}}},"pageContext":{"slug":"/projects/Static_Single_Assignment(SSA)_in_compilers/ssa/"}},"staticQueryHashes":["3649515864","63159454"]}